
with open(0) as f:
    lines = [x.strip() for x in f.readlines()]

bricks = []

for start, end in [line.split("~") for line in lines]:
    start = list(map(int, start.split(",")))
    end = list(map(int, end.split(",")))
    assert all(a <= b for a, b in zip(start, end))

    brick = set()

    for x in range(start[0], end[0] + 1):
        for y in range(start[1], end[1] + 1):
            for z in range(start[2], end[2] + 1):
                brick.add((x, y, z))

    bricks.append(brick)

bricks = sorted(bricks, key=lambda b: min(a[2] for a in b))
print(bricks)
placed = {}

for i in range(len(bricks)):
    print(i, "/", len(bricks), "stacked")
    while all(z > 1 for x, y, z in bricks[i]) and len(placed) != len(bricks):
        new_brick = set()

        for b in bricks[i]:
            x, y, z = b
            new_brick.add((x, y, z - 1))

        intersecting = False

        for a in range(len(bricks) - 1):
            for b in range(len(bricks)):
                if len(bricks[a] & bricks[b]) != 0:
                    intersecting = True
                    break
            if intersecting:
                break

        if not intersecting:
            bricks[i] = new_brick
        else:
            placed[i] = True
        print(new_brick)

for a in range(len(bricks) - 1):
    for b in range(i, len(bricks)):
        assert len(bricks[a] & bricks[b]) == 0


safe = 0

for i, brick in enumerate(bricks):
    print("checking", i, "/", len(bricks))
    supporting = False
    x, y, z = max(brick, key = lambda b: b[0])
    for b2 in [t for t in bricks if t != brick]:
        if any(x2 == x and y2 == y and z2 == z + 1 for x2, y2, z2 in b2):
            supporting = True
            break

    if supporting:
        continue

    safe += 1

print(bricks)
print(safe)
























